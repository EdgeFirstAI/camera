# GitHub Actions workflow for testing and code quality
#
# This workflow runs tests, performs static analysis, and collects coverage data
# for the EdgeFirst Camera project. Coverage is reported to SonarCloud.
#
# Three-phase architecture for on-target testing:
# - Phase 1: Build instrumented binaries on ubuntu-22.04-arm
# - Phase 2: Run hardware integration tests on nxp-imx8mp-latest runner
# - Phase 3: Process coverage data and report to SonarCloud
#
# Action Versions (hash-pinned, verified January 2026):
# - actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98 (v4.2.2)
# - actions/cache@5a3ec84eff668545956fd18022155c47e93e2684 (v4.2.3)
# - actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f (v6.0.0)
# - actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131 (v7.0.0)
# - dtolnay/rust-toolchain@stable
# - taiki-e/install-action@7e574ed8bb89811282a11aecb3fe1d043bf5bf0e (v2)
# - SonarSource/sonarqube-scan-action@a31c9398be7ace6bbfaf30c0bd5d415f843d45e9 (master)
#
# Runner Notes:
# - ubuntu-22.04: Standard GitHub-hosted runner (x86_64)
# - ubuntu-22.04-arm: GitHub-hosted ARM64 runner for native aarch64 builds/tests
# - nxp-imx8mp-latest: Self-hosted NXP i.MX 8M Plus EVK with camera hardware

name: Test

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main, develop]

env:
  CARGO_TERM_COLOR: always

jobs:
  format:
    name: Format Check
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout code
        uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98  # v4.2.2

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: rustfmt

      - name: Check formatting
        run: cargo fmt --all --check

  clippy:
    name: Lint with Clippy
    runs-on: ubuntu-22.04

    steps:
      - name: Checkout code
        uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98  # v4.2.2

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: clippy

      - name: Cache cargo registry
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684  # v4.2.3
        with:
          path: ~/.cargo/registry/index
          key: ${{ runner.os }}-cargo-index-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-index-

      - name: Cache cargo build
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684  # v4.2.3
        with:
          path: target
          key: ${{ runner.os }}-cargo-clippy-${{ hashFiles('**/Cargo.lock') }}
          restore-keys: ${{ runner.os }}-cargo-clippy-

      - name: Run Clippy
        run: cargo clippy --workspace --all-targets --all-features -- -D warnings

      - name: Generate Clippy report for SonarCloud
        run: |
          # Generate JSON report for SonarCloud (allow warnings for report generation)
          cargo clippy --workspace --all-targets --all-features --message-format=json 2>&1 \
            | tee clippy-report.json || true

      - name: Upload Clippy report
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: clippy-report
          path: clippy-report.json
          retention-days: 7

  # ==========================================================================
  # Phase 1: Build & Unit Test on GitHub-hosted runners
  # ==========================================================================
  test:
    name: Test and Coverage (${{ matrix.platform.name }})
    runs-on: ${{ matrix.platform.runner }}
    permissions:
      contents: read
      checks: write
      pull-requests: write
    strategy:
      matrix:
        platform:
          - name: x86_64
            runner: ubuntu-22.04
            target: x86_64-unknown-linux-gnu
          - name: aarch64
            runner: ubuntu-22.04-arm
            target: aarch64-unknown-linux-gnu
      fail-fast: false

    steps:
      - name: Checkout code
        uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98  # v4.2.2
        with:
          fetch-depth: 0

      - name: Install system dependencies
        run: |
          sudo apt-get update
          sudo apt-get install -y nasm

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview
          targets: ${{ matrix.platform.target }}

      - name: Install cargo-llvm-cov and cargo-nextest
        uses: taiki-e/install-action@7e574ed8bb89811282a11aecb3fe1d043bf5bf0e  # v2
        with:
          tool: cargo-llvm-cov,cargo-nextest

      - name: Cache cargo registry
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684  # v4.2.3
        with:
          path: ~/.cargo/registry/index
          key: ${{ runner.os }}-${{ matrix.platform.name }}-cargo-index
          restore-keys: ${{ runner.os }}-${{ matrix.platform.name }}-cargo-index

      - name: Cache cargo build
        uses: actions/cache@5a3ec84eff668545956fd18022155c47e93e2684  # v4.2.3
        with:
          path: target
          key: ${{ runner.os }}-${{ matrix.platform.name }}-cargo-test
          restore-keys: ${{ runner.os }}-${{ matrix.platform.name }}-cargo-test

      - name: Run unit tests with coverage
        run: |
          # This is a binary-only crate with no library unit tests
          # Integration tests require hardware (DMA heap) and run on imx8mp runner
          # Generate a minimal coverage report for CI purposes
          echo "Note: No library unit tests in this crate (binary-only)"
          echo "Coverage is collected from integration tests on hardware runner"
          
          # Create empty coverage file so artifact upload doesn't fail
          # Real coverage comes from hardware tests
          touch coverage.lcov

      - name: Build instrumented binary for integration tests (aarch64 only)
        if: matrix.platform.name == 'aarch64'
        run: |
          # Source coverage environment and build instrumented binary
          source <(cargo llvm-cov show-env --export-prefix)
          export CARGO_TARGET_DIR=target/llvm-cov-target

          # Build the main binary with coverage instrumentation using profiling profile
          cargo build --profile profiling

          # Build integration tests with coverage instrumentation
          cargo nextest run --workspace --no-run --run-ignored=all --cargo-profile profiling || true

          # Prepare artifacts
          mkdir -p instrumented-binaries
          cp target/llvm-cov-target/profiling/edgefirst-camera instrumented-binaries/

          # Copy instrumented integration test binaries
          find target/llvm-cov-target/profiling/deps -name "test_image*" -type f -executable \
            -exec cp {} instrumented-binaries/ \; 2>/dev/null || true

          echo "Instrumented binaries prepared:"
          ls -lh instrumented-binaries/

      - name: Upload coverage artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: coverage-${{ matrix.platform.name }}
          path: coverage.lcov
          retention-days: 30
          if-no-files-found: ignore

      - name: Upload instrumented binaries (aarch64 only)
        if: matrix.platform.name == 'aarch64'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: instrumented-binaries-aarch64
          path: instrumented-binaries/
          retention-days: 7

      - name: Upload Rust instrumented objects for coverage processing (aarch64 only)
        if: matrix.platform.name == 'aarch64'
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: rust-llvm-cov-aarch64
          path: target/llvm-cov-target/
          retention-days: 7

  # ==========================================================================
  # Phase 2: Hardware Integration Tests
  # ==========================================================================
  hardware-test:
    name: Hardware Integration Tests
    needs: test
    runs-on: nxp-imx8mp-latest
    # Only run on main branch or when explicitly requested via label
    if: github.ref == 'refs/heads/main' || contains(github.event.pull_request.labels.*.name, 'test-hardware')

    steps:
      - name: Clean workspace (self-hosted runner)
        run: |
          # Self-hosted runners persist state between runs
          rm -rf target/ instrumented-binaries/ coverage/ 2>/dev/null || true
          find . -name "*.profraw" -delete 2>/dev/null || true
          # Clean /tmp to avoid filling memory filesystem
          rm -rf /tmp/test_* /tmp/edgefirst-camera* /tmp/profraw 2>/dev/null || true

      - name: Checkout code
        uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98  # v4.2.2

      - name: Download instrumented binaries
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: instrumented-binaries-aarch64
          path: instrumented-binaries/

      - name: Make binaries executable
        run: chmod +x instrumented-binaries/*

      - name: Download VideoStream library
        run: |
          # Download VideoStream release for aarch64
          curl -sL https://github.com/EdgeFirstAI/videostream/releases/download/v2.1.4/videostream-2.1.4-linux-aarch64.zip -o videostream.zip
          unzip -q videostream.zip -d videostream
          echo "VideoStream library extracted:"
          find videostream -name "*.so*" -type f

      - name: Run hardware integration tests
        env:
          # Set up profraw collection for coverage
          LLVM_PROFILE_FILE: ${{ github.workspace }}/coverage/profraw/imx8mp-%p-%m.profraw
          LD_LIBRARY_PATH: ${{ github.workspace }}/videostream/lib/aarch64-linux-gnu
        run: |
          # Set up profraw collection directory
          mkdir -p coverage/profraw coverage/test-output

          # Track overall test status
          TEST_FAILED=0

          # Test 1: Binary help output (generates profraw on clean exit)
          echo "=== Testing binary help output ==="
          ./instrumented-binaries/edgefirst-camera --help

          # Test 2: JPEG capture (15 seconds)
          # Note: timeout kills the process, so we won't get profraw from this
          # Coverage comes from integration tests below
          echo ""
          echo "=== Testing JPEG capture (15 seconds) ==="
          timeout 15 ./instrumented-binaries/edgefirst-camera --jpeg 2>&1 || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 124 ]; then
              echo "âœ“ Camera ran successfully for 15 seconds"
            else
              echo "JPEG test failed with exit code $EXIT_CODE"
              TEST_FAILED=1
            fi
          }

          # Test 3: H.264 encoding (15 seconds)
          echo ""
          echo "=== Testing H.264 encoding (15 seconds) ==="
          timeout 15 ./instrumented-binaries/edgefirst-camera --h264 2>&1 || {
            EXIT_CODE=$?
            if [ $EXIT_CODE -eq 124 ]; then
              echo "âœ“ Camera ran successfully for 15 seconds"
            else
              echo "H.264 test failed with exit code $EXIT_CODE"
              TEST_FAILED=1
            fi
          }

          # Test 4: Run instrumented integration test binaries
          # These tests exit cleanly and WILL generate profraw coverage files
          echo ""
          echo "=== Running instrumented integration test binaries ==="
          for test_bin in instrumented-binaries/test_image*; do
            if [ -x "$test_bin" ] && [ -f "$test_bin" ]; then
              test_name=$(basename "$test_bin")
              echo "--- Running $test_name ---"
              if ! "$test_bin" --test-threads=1 --include-ignored 2>&1 | tee "coverage/test-output/${test_name}.txt"; then
                echo "FAILED: $test_name"
                TEST_FAILED=1
              fi
            fi
          done

          echo ""
          echo "=== Profraw files generated ==="
          ls -la coverage/profraw/ || echo "No profraw files generated"
          find coverage/profraw/ -name "*.profraw" -exec ls -lh {} \; 2>/dev/null || true

          # Fail the step if any test failed
          if [ $TEST_FAILED -ne 0 ]; then
            echo ""
            echo "ERROR: One or more integration tests failed!"
            exit 1
          fi

      - name: Upload hardware coverage artifact
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        if: always()
        with:
          name: coverage-hardware
          path: |
            coverage/profraw/
            coverage/test-output/
          retention-days: 30

      - name: Clean up /tmp (self-hosted runner)
        if: always()
        run: |
          # Clean /tmp to avoid filling memory filesystem on self-hosted runner
          rm -rf /tmp/test_* /tmp/edgefirst-camera* /tmp/profraw 2>/dev/null || true
          # Clean workspace as well
          rm -rf instrumented-binaries/ coverage/ videostream/ videostream.zip 2>/dev/null || true

  # ==========================================================================
  # Phase 3: Process Hardware Coverage
  # ==========================================================================
  process-hardware-coverage:
    name: Process Hardware Coverage
    needs: [test, hardware-test]
    runs-on: ubuntu-22.04-arm
    # Only run if hardware-test ran (even if it failed, to collect partial coverage)
    if: always() && needs.test.result == 'success' && (needs.hardware-test.result == 'success' || needs.hardware-test.result == 'failure')

    steps:
      - name: Checkout code
        uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98  # v4.2.2

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          components: llvm-tools-preview

      - name: Download Rust instrumented objects
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: rust-llvm-cov-aarch64
          path: target/llvm-cov-target/

      - name: Download hardware coverage artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: coverage-hardware
          path: coverage-hardware/

      - name: Process profraw files into coverage report
        run: |
          echo "=== Downloaded llvm-cov-target directory ==="
          ls -la target/llvm-cov-target/ || echo "Directory not found"

          echo ""
          echo "=== Profraw files from hardware ==="
          find coverage-hardware/ -name "*.profraw" -type f || echo "No profraw files found"

          PROFRAW_COUNT=$(find coverage-hardware/ -name "*.profraw" 2>/dev/null | wc -l)
          echo "Found $PROFRAW_COUNT profraw files"

          if [ "$PROFRAW_COUNT" -eq 0 ]; then
            echo "WARNING: No profraw files found from hardware tests - skipping coverage"
            exit 0
          fi

          # Find LLVM tools from Rust toolchain
          TOOLCHAIN_ROOT=$(rustc --print sysroot)
          LLVM_PROFDATA=$(find "$TOOLCHAIN_ROOT" -name "llvm-profdata" -type f | head -1)
          LLVM_COV=$(find "$TOOLCHAIN_ROOT" -name "llvm-cov" -type f | head -1)

          if [ -z "$LLVM_PROFDATA" ] || [ -z "$LLVM_COV" ]; then
            echo "ERROR: Could not find LLVM tools in Rust toolchain"
            exit 1
          fi

          echo ""
          echo "Using LLVM tools:"
          echo "  llvm-profdata: $LLVM_PROFDATA"
          echo "  llvm-cov: $LLVM_COV"

          # Merge profraw files into profdata
          echo ""
          echo "=== Merging profraw files ==="
          mkdir -p coverage
          "$LLVM_PROFDATA" merge -sparse \
            $(find coverage-hardware/ -name "*.profraw" -type f) \
            -o coverage/hardware.profdata

          if [ ! -f coverage/hardware.profdata ]; then
            echo "ERROR: Failed to merge profraw files"
            exit 1
          fi
          echo "Created coverage/hardware.profdata"

          # Find all instrumented binaries
          echo ""
          echo "=== Finding instrumented binaries ==="
          OBJECT_FILES=""
          for obj in $(find target/llvm-cov-target/profiling -maxdepth 2 -type f ! -name "*.d" ! -name "*.rlib" ! -name "*.rmeta" 2>/dev/null); do
            if file "$obj" | grep -q "ELF"; then
              if [ -z "$OBJECT_FILES" ]; then
                OBJECT_FILES="$obj"
              else
                OBJECT_FILES="$OBJECT_FILES --object=$obj"
              fi
            fi
          done

          # Also check deps directory
          for obj in $(find target/llvm-cov-target/profiling/deps -maxdepth 1 -type f ! -name "*.d" ! -name "*.rlib" ! -name "*.rmeta" 2>/dev/null); do
            if file "$obj" | grep -q "ELF"; then
              OBJECT_FILES="$OBJECT_FILES --object=$obj"
            fi
          done

          if [ -z "$OBJECT_FILES" ]; then
            echo "ERROR: No ELF binaries found in target/llvm-cov-target/profiling/"
            exit 1
          fi

          echo "Found binaries for coverage analysis"

          # Generate coverage report
          echo ""
          echo "=== Generating coverage report ==="
          "$LLVM_COV" export \
            --format=lcov \
            --instr-profile=coverage/hardware.profdata \
            --ignore-filename-regex='/.cargo/registry|/rustc/' \
            $OBJECT_FILES \
            > coverage/coverage-hardware.lcov

          if [ ! -s coverage/coverage-hardware.lcov ]; then
            echo "ERROR: Failed to generate coverage report (empty file)"
            exit 1
          fi

          echo "Generated coverage/coverage-hardware.lcov"
          wc -l coverage/coverage-hardware.lcov

      - name: Upload processed hardware coverage
        uses: actions/upload-artifact@b7c566a772e6b6bfb58ed0dc250532a479d7789f  # v6.0.0
        with:
          name: coverage-hardware-processed
          path: coverage/coverage-hardware.lcov
          retention-days: 30
          if-no-files-found: ignore

  # ==========================================================================
  # SonarCloud Analysis
  # ==========================================================================
  sonarcloud:
    name: SonarCloud Analysis
    runs-on: ubuntu-22.04
    needs: [clippy, test, hardware-test, process-hardware-coverage]
    # Run if test succeeded, even if hardware tests were skipped
    if: |
      always() &&
      needs.test.result == 'success' &&
      (github.event_name == 'push' || github.event.pull_request.head.repo.full_name == github.repository)

    steps:
      - name: Checkout code
        uses: actions/checkout@0c366fd6a839edf440554fa01a7085ccba70ac98  # v4.2.2
        with:
          fetch-depth: 0

      - name: Download coverage artifacts
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          pattern: coverage-*
          path: coverage/

      - name: Download Clippy report
        uses: actions/download-artifact@37930b1c2abaa49bbe596cd826c3c89aef350131  # v7.0.0
        with:
          name: clippy-report
          path: .

      - name: Organize coverage files for SonarCloud
        run: |
          echo "=== Downloaded coverage artifacts ==="
          find coverage/ -type f

          # Collect all LCOV coverage reports
          COVERAGE_REPORTS=$(find coverage/ -name "*.lcov" | tr '\n' ',' | sed 's/,$//')

          echo "=== Coverage report paths ==="
          echo "Coverage reports: $COVERAGE_REPORTS"

          # Export for SonarCloud
          echo "COVERAGE_PATHS=$COVERAGE_REPORTS" >> $GITHUB_ENV

          echo ""
          echo "=== Clippy report ==="
          ls -la clippy-report.json || echo "No Clippy report found"

      - name: SonarCloud Scan
        uses: SonarSource/sonarqube-scan-action@a31c9398be7ace6bbfaf30c0bd5d415f843d45e9  # master
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
        with:
          args: >
            -Dsonar.rust.lcov.reportPaths=${{ env.COVERAGE_PATHS }}
            -Dsonar.rust.clippy.reportPaths=clippy-report.json

      - name: Generate coverage summary
        if: always()
        run: |
          echo "# ðŸ“Š EdgeFirst Camera Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Test Platforms
          echo "## ðŸ”§ Test Platforms" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "| Platform | Architecture | Environment | Test Types |" >> $GITHUB_STEP_SUMMARY
          echo "|----------|--------------|-------------|------------|" >> $GITHUB_STEP_SUMMARY
          echo "| Ubuntu 22.04 | x86_64 | GitHub Runner | Unit tests |" >> $GITHUB_STEP_SUMMARY
          echo "| Ubuntu 22.04 ARM | aarch64 | GitHub ARM Runner | Unit tests |" >> $GITHUB_STEP_SUMMARY
          if [ "${{ needs.hardware-test.result }}" != "skipped" ]; then
            echo "| NXP i.MX8MP | aarch64 | Real Hardware | Integration tests with camera, G2D, VPU |" >> $GITHUB_STEP_SUMMARY
          fi
          echo "" >> $GITHUB_STEP_SUMMARY

          # Coverage Summary
          echo "## ðŸ“ˆ Coverage Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          # Parse coverage from LCOV files
          for coverage_file in $(find coverage/ -name "*.lcov" 2>/dev/null | sort); do
            if [ -f "$coverage_file" ]; then
              platform=$(basename "$(dirname "$coverage_file")" | sed 's/coverage-//')

              # Extract coverage metrics from LCOV (trim whitespace from wc output)
              lines_found=$(grep -c "^DA:" "$coverage_file" 2>/dev/null || echo 0)
              lines_hit=$(grep "^DA:" "$coverage_file" 2>/dev/null | grep -v ",0$" | wc -l | tr -d ' ')

              # Ensure numeric values
              lines_found=${lines_found:-0}
              lines_hit=${lines_hit:-0}

              if [ "$lines_found" -gt 0 ] 2>/dev/null; then
                line_pct=$(awk "BEGIN {printf \"%.1f\", ($lines_hit / $lines_found) * 100}")

                echo "**$platform**:" >> $GITHUB_STEP_SUMMARY
                echo "- Line coverage: ${line_pct}% (${lines_hit}/${lines_found} lines)" >> $GITHUB_STEP_SUMMARY
                echo "" >> $GITHUB_STEP_SUMMARY
              fi
            fi
          done

          echo "" >> $GITHUB_STEP_SUMMARY
          echo "ðŸ“‹ Full analysis available on [SonarCloud](https://sonarcloud.io/dashboard?id=EdgeFirstAI_camera)" >> $GITHUB_STEP_SUMMARY
